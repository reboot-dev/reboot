/* eslint-disable */
// @ts-nocheck

import { reboot_native, ensureError } from "@reboot-dev/reboot";
{% if import_ids|length > 0 %}
{% for unique_import_id, path in import_ids.items() %}
import { importPys as {{ unique_import_id }}importPys } from "{{ path }}{% if nodejs_extensions %}.js{% endif %}"
{% endfor %}
{% endif %}

{#
NOTE: The following if block includes most of the rest of this file. Most of
this generated code is meant for Reboot states and clients. In some cases, we
generate _rbt files for services that are not Reboot states or clients, to help
with transitive imports. grep for 'END REBOOT SPECIFIC CODE' to see the end of
this if block.
#}
{# BEGIN REBOOT SPECIFIC CODE #}
{% if clients | length > 0 %}

{% if google_protobuf_used_messages is defined and google_protobuf_used_messages|length > 0%}
import {
  {{ google_protobuf_used_messages|join(', \n  ') }}
} from "@bufbuild/protobuf";
{% endif %}
{% if proto.messages_and_enums | length > 0 and not options.proto.zod %}
// Additionally re-export all messages_and_enums from the pb module.
export {
  {% for message in proto.messages_and_enums | unique | list %}
  {{ message }},
  {% endfor %}
} from "./{{ pb_name }}{% if nodejs_extensions %}.js{% endif %}";

{% endif %}

{# Since we are creating a new class named {{ state.proto.name }}, we
cannot import it from {{ pb_name }}.js as it would conflict. Instead
we alias it inside this file and export that type as {{
state.proto.name }}.State for developers to use. When a user is
using Zod {{ state.proto.name }}.State aliases to their Zod type. #}
{% if states|length > 0 %}
{% for state in states %}
import {
  {# NOTE: we already rewrite state types that are used in `method.input_type`
   or `method.output_type` with a `Proto` suffix to not conflict with our
   new class named {{ state.proto.name }}, so that is what we want to
   import as. #}
  {{ state.proto.name }} as {{ state.proto.name }}Proto,
} from "./{{ pb_name }}{% if nodejs_extensions %}.js{% endif %}";
{% endfor %}
{% endif %}

{# We import this because many `method.input_type` or `method.output_type` has
already been converted to use `pb_name`. #}
import * as {{ pb_name }} from "./{{ pb_name }}{% if nodejs_extensions %}.js{% endif %}";

import * as uuid from "uuid";

import * as reboot from "@reboot-dev/reboot";
import {
  Context,
  ExternalContext,
  WorkflowContext,
  ReaderContext,
  WriterContext,
  TransactionContext,
} from "@reboot-dev/reboot";
import * as protobuf_es from "@bufbuild/protobuf";
import * as reboot_api from "@reboot-dev/reboot-api";

{% if imports|length > 0 %}
// Include all transitive imports.
{% for import_path, unique_name in imports.items() %}
import * as {{ unique_name }} from "{{ import_path }}{% if nodejs_extensions %}.js{% endif %}";
{% endfor %}
{% endif %}

{% if options.proto.zod %}
import { z } from "zod/v4";
import { api } from "{{ options.proto.zod }}{% if nodejs_extensions %}.js{% endif %}";
{% endif %}

// To support writers seeing partial updates of transactions,
// and transactions seeing updates from writers, we need to store
// a reference to the latest state in an ongoing transaction.
//
// Moreover, we need to update that _reference_ after each writer
// executes within a transaction. We do that in the generated
// code, see below.
const ongoingTransactionStates: { [id: string] : any; } = {};

const ERROR_TYPES = [
  // gRPC errors.
  reboot_api.errors_pb.Cancelled,
  reboot_api.errors_pb.Unknown,
  reboot_api.errors_pb.InvalidArgument,
  reboot_api.errors_pb.DeadlineExceeded,
  reboot_api.errors_pb.NotFound,
  reboot_api.errors_pb.AlreadyExists,
  reboot_api.errors_pb.PermissionDenied,
  reboot_api.errors_pb.ResourceExhausted,
  reboot_api.errors_pb.FailedPrecondition,
  reboot_api.errors_pb.Aborted,
  reboot_api.errors_pb.OutOfRange,
  reboot_api.errors_pb.Unimplemented,
  reboot_api.errors_pb.Internal,
  reboot_api.errors_pb.Unavailable,
  reboot_api.errors_pb.DataLoss,
  reboot_api.errors_pb.Unauthenticated,
  // Reboot errors.
  //
  // NOTE: also add any new errors into `rbt/v1alpha1/index.ts`.
  reboot_api.errors_pb.StateAlreadyConstructed,
  reboot_api.errors_pb.StateNotConstructed,
  reboot_api.errors_pb.TransactionParticipantFailedToPrepare,
  reboot_api.errors_pb.TransactionParticipantFailedToCommit,
  reboot_api.errors_pb.UnknownService,
  reboot_api.errors_pb.UnknownTask,
] as const; // Need `as const` to ensure TypeScript infers this as a tuple!

{# Start generated Servicer code #}

{% for client in clients %}

const {{ client.proto.state_name }}FromJsonString = (
  jsonState: string,
  options: { validate: boolean } = { validate: true }
): {{ client.proto.state_name }}.State => {
  {% if options.proto.zod %}
  if (options.validate) {
    return reboot_api.validate(
      "{{ client.proto.state_name }}.state",
      api.{{ client.proto.state_name }}.state,
      reboot_api.convertFromProtobuf(
        api.{{ client.proto.state_name }}.state,
        {{ client.proto.state_name }}State.fromJsonString(jsonState)
      )
    );
  } else {
    return reboot_api.convertFromProtobuf(
      api.{{ client.proto.state_name }}.state,
      {{ client.proto.state_name }}State.fromJsonString(jsonState)
    );
  }
  {% else %}
  return {{ client.proto.state_name }}State.fromJsonString(jsonState);
  {% endif %}
};

const {{ client.proto.state_name }}FromBinary = (
  bytesState: Uint8Array
): {{ client.proto.state_name }}.State => {
  {% if options.proto.zod %}
  return reboot_api.validate(
    "{{ client.proto.state_name }}.state",
    api.{{ client.proto.state_name }}.state,
    reboot_api.convertFromProtobuf(
      api.{{ client.proto.state_name }}.state,
      {{ client.proto.state_name }}State.fromBinary(bytesState)
    )
  );
  {% else %}
  return {{ client.proto.state_name }}State.fromBinary(bytesState);
  {% endif %}
};

const {{ client.proto.state_name }}ToProtobuf = (
  state: {{ client.proto.state_name }}.State
): {{ client.proto.state_name }}State => {
  return state instanceof {{ client.proto.state_name }}State
    ? state
    : {{ client.proto.state_name }}State.fromJson(
      {% if options.proto.zod %}
      reboot_api.convertToProtobufJson(
        api.{{ client.proto.state_name }}.state,
        reboot_api.validate(
          "{{ client.proto.state_name }}.state",
          api.{{ client.proto.state_name }}.state,
          state
        )
      )
      {% else %}
      state
      {% endif %}
    );
};

{% for service in client.services %}
{% for method in service.methods %}

// Helper for getting the expected shape of a request, i.e., either a
// Zod shape or a protobuf instance, from a protobuf shape.
const {{ client.proto.state_name }}{{ method.proto.name }}RequestFromProtobufShape = (
  partialRequest: protobuf_es.PartialMessage<{{ method.input_type }}>
): {{ client.proto.state_name }}.{{ method.proto.name }}Request => {
  // TOOD: update `convertFromProtobuf()` to actually work from
  // any objects that match the shape, not just protobuf instances,
  // and then we won't need to first call `fromJson()` here.
  const request = partialRequest instanceof {{ method.input_type }}
    ? partialRequest
    : {{ method.input_type }}.fromJson(partialRequest);

  {% if options.proto.zod %}
  return reboot_api.validate(
    "{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.request",
    api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.request,
    reboot_api.convertFromProtobuf(
      api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.request,
      request
    )
  );
  {% else %}
  return request;
  {% endif %}
};

// Helper for getting the expected shape of a request, i.e., either a
// Zod shape or a protobuf instance, from a JSON string.
const {{ client.proto.state_name }}{{ method.proto.name }}RequestFromJsonString = (
  jsonRequest: string
): {{ client.proto.state_name }}.{{ method.proto.name }}Request => {
  return {{ client.proto.state_name }}{{ method.proto.name }}RequestFromProtobufShape(
    {{ method.input_type }}.fromJsonString(jsonRequest)
  );
};

// Helper for getting a protobuf instance for a request from the
// expected shape, i.e., either a Zod shape or a protobuf shape.
const {{ client.proto.state_name }}{{ method.proto.name }}RequestToProtobuf = (
  partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request
): {{ method.input_type }} => {
  return partialRequest instanceof {{ method.input_type }}
    ? partialRequest
    : new {{ method.input_type }}(
      {% if options.proto.zod %}
      reboot_api.convertToProtobufJson(
        api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.request,
        reboot_api.validate(
          "{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.request",
          api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.request,
          partialRequest || {}
        )
      )
      {% else %}
      partialRequest
      {% endif %}
    );
};

const {{ client.proto.state_name }}{{ method.proto.name }}ResponseFromProtobufShape = (
  partialResponse: protobuf_es.PartialMessage<{{ method.output_type }}>
) => {
  // TOOD: update `convertFromProtobuf()` to actually work from
  // any objects that match the shape, not just protobuf instances,
  // and then we won't need to first call `fromJson()` here.
  const response = partialResponse instanceof {{ method.output_type }}
    ? partialResponse
    : {{ method.output_type }}.fromJson(partialResponse);

  {% if options.proto.zod %}
  return reboot_api.validate(
    "{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.response",
    api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.response,
    reboot_api.convertFromProtobuf(
      api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.response,
      response
    )
  );
  {% else %}
  return response;
  {% endif %}
};

const {{ client.proto.state_name }}{{ method.proto.name }}ResponseToProtobuf = (
  partialResponse?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Response
): {{ method.output_type }} => {
  return partialResponse instanceof {{ method.output_type }}
    ? partialResponse
    : new {{ method.output_type }}(
      {% if options.proto.zod %}
      reboot_api.convertToProtobufJson(
        api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.response,
        reboot_api.validate(
          "{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.response",
          api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.response,
          partialResponse
        )
      )
      {% else %}
      partialResponse
      {% endif %}
    );
};

{% endfor %}
{% endfor %}

export type {{ client.proto.state_name }}RequestTypes =
{% for service in client.services %}
{% for method in service.methods %}
  | {{ client.proto.state_name }}.{{ method.proto.name }}Request
{% endfor %}
{% endfor %};

{# TODO: do not generate errors in react, nodejs and web. #}
{% for service in client.services %}
{% for method in service.methods %}
const {{ client.proto.state_name | to_screaming_snake }}_{{ method.proto.name | to_screaming_snake }}_ERROR_TYPES = [
  ...ERROR_TYPES,
  // Method errors.
  {% for type in method.options.errors.values() %}
  {{ type }},
  {% endfor %}
] as const; // Need `as const` to ensure TypeScript infers this as a tuple!

type {{ client.proto.state_name | to_camel }}{{ method.proto.name | to_camel }}AbortedError =
  reboot_api.InstanceTypeForErrorTypes<
    typeof {{ client.proto.state_name | to_screaming_snake }}_{{ method.proto.name | to_screaming_snake }}_ERROR_TYPES
  >[number];

{% endfor %}
{% endfor %}

{% endfor %}

{% for state in states %}

export type {{ state.proto.name }}ObjectLiteral = {
  authorizer?: () => reboot.Authorizer<{{ state.proto.name }}.State, {{ state.proto.name }}RequestTypes> | reboot.AuthorizerRule<{{ state.proto.name }}.State, {{ state.proto.name }}RequestTypes> | null;

  {% for service in state.services %}
  {% for method in service.methods %}
  {{ method.proto.name | to_lower_camel }}: (
    {% if method.options.proto.kind == 'reader' %}
    context: ReaderContext,
    {% elif method.options.proto.kind == 'writer' %}
    context: WriterContext,
    {% elif method.options.proto.kind == 'transaction' %}
    context: TransactionContext,
    {% elif method.options.proto.kind == 'workflow' %}
    context: WorkflowContext,
    {% endif %}
    {% if method.options.proto.kind != 'workflow' %}
    state: {{ state.proto.name }}.State,
    {% else %}
    state: {{ state.proto.name }}.WorkflowState,
    {% endif %}
    request: {{ state.proto.name }}.{{ method.proto.name }}Request,
  ) => Promise<
    {% if method.options.proto.kind == 'reader' %}
    {{ state.proto.name }}.Partial{{ method.proto.name }}Response
    {% elif method.options.proto.kind != 'workflow' %}
    {{ state.proto.name }}.{{ method.proto.name }}Response extends void
      ? [{{ state.proto.name }}.State]
      : [
        {{ state.proto.name }}.State,
        {{ state.proto.name }}.Partial{{ method.proto.name }}Response,
      ]
    {% else %}
    {{ state.proto.name }}.Partial{{ method.proto.name }}Response
    | reboot.Loop
  {% endif %}
  >;
  {% endfor %}
  {% endfor %}
};

export abstract class {{ state.proto.name }}Servicer extends reboot.Servicer<{{ state.proto.name }}State> {
  static __rbtModule__ = "{{ rbt_name }}";
  static __servicerNodeAdaptor__ = "{{ state.proto.name }}ServicerNodeAdaptor";

  // External reference to the native `Servicer`.
  #external?: any | undefined;

  public ref(
    options?: { bearerToken?: string }
  ) {
    const context = reboot.getContext();
    return new {{ state.proto.name }}.WeakReference(context.stateId, options?.bearerToken);
  }

  public static servicer(literal: {{ state.proto.name }}ObjectLiteral) {
    return class extends {{ state.proto.name }}Servicer {
      authorizer() {
        if (literal.authorizer !== undefined) {
          return literal.authorizer();
        }
        return super.authorizer();
      }

      {% for service in state.services %}
      {% for method in service.methods %}
      async {{ method.proto.name | to_lower_camel }} (
        {% if method.options.proto.kind == 'reader' %}
        context: ReaderContext,
        {% elif method.options.proto.kind == 'writer' %}
        context: WriterContext,
        {% elif method.options.proto.kind == 'transaction' %}
        context: TransactionContext,
        {% elif method.options.proto.kind == 'workflow' %}
        context: WorkflowContext,
        {% endif %}
        {% if method.options.proto.kind != 'workflow' %}
        state: {{ state.proto.name }}.State,
        {% endif %}
        request: {{ state.proto.name }}.{{ method.proto.name }}Request,
      ): Promise<
        {{ state.proto.name }}.Partial{{ method.proto.name }}Response
      {% if method.options.proto.kind == 'workflow' %}
      | reboot.Loop
      {% endif %}
      > {
        {% if method.options.proto.kind == 'reader' %}
        return await literal.{{ method.proto.name | to_lower_camel }}(
          context,
          state,
          request
        );
        {% elif method.options.proto.kind != 'workflow' %}
        const [updatedState, response] = await literal.{{ method.proto.name | to_lower_camel }}(
          context,
          state,
          request
        );
        Object.assign(state, updatedState);
        return response;
        {% else %}
        return await literal.{{ method.proto.name | to_lower_camel }}(
          context,
          this.state,
          request
        );
        {% endif %}
      }

      {% endfor %}
      {% endfor %}
    };
  }

  {% for service in state.services %}
  {% for method in service.methods %}
  abstract {{ method.proto.name | to_lower_camel }}(
    {% if method.options.proto.kind == 'reader' %}
    context: ReaderContext,
    {% elif method.options.proto.kind == 'writer' %}
    context: WriterContext,
    {% elif method.options.proto.kind == 'transaction' %}
    context: TransactionContext,
    {% elif method.options.proto.kind == 'workflow' %}
    context: WorkflowContext,
    {% endif %}
    {% if method.options.proto.kind != 'workflow' %}
    state: {{ state.proto.name }}.State,
    {% endif %}
    request: {{ state.proto.name }}.{{ method.proto.name }}Request,
  ): Promise<
    {{ state.proto.name }}.Partial{{ method.proto.name }}Response
  {% if method.options.proto.kind == 'workflow' %}
  | reboot.Loop
  {% endif %}
  >;

  async _{{ method.proto.name }}(
    {% if method.options.proto.kind == 'reader' %}
    context: ReaderContext,
    {% elif method.options.proto.kind == 'writer' %}
    context: WriterContext,
    {% elif method.options.proto.kind == 'transaction' %}
    context: TransactionContext,
    {% elif method.options.proto.kind == 'workflow' %}
    context: WorkflowContext,
    {% endif %}
    jsonState: string,
    jsonRequest: string
  ): Promise<string> {
    try {
      {% if method.options.proto.kind != 'workflow' %}
      let state = {{ state.proto.name }}FromJsonString(
        jsonState,
        // Don't validate if we're a constructor because non-optional
        // fields that this constructor might be setting will be invalid.
        { validate: {% if method.options.proto.constructor %}false{% else %}true{% endif %} },
      );
      {% endif %}
      {% if method.options.proto.kind == 'writer' %}
      if (context.stateId in ongoingTransactionStates) {
        {% if options.proto.zod %}
        state = reboot_api.convertFromProtobufShape(
          api.{{ state.proto.name }}.state,
          ongoingTransactionStates[context.stateId].clone()
        );
        {% else %}
        state = ongoingTransactionStates[context.stateId].clone();
        {% endif %}
      }
      {% elif method.options.proto.kind == 'transaction' %}
      // TODO: assert that there are no ongoing transactions for this state.
      ongoingTransactionStates[context.stateId] = state;
      {% endif %}

      let request = {{ state.proto.name }}{{ method.proto.name }}RequestFromJsonString(jsonRequest);

      let partialResponse = await reboot.runWithContext(context, () => {
        return this.{{ method.proto.name | to_lower_camel }}(
          context,
          {% if method.options.proto.kind != 'workflow' %}
          state,
          {% endif %}
          request
        );
      });

      const response = {% if method.options.proto.kind == 'workflow' %}partialResponse instanceof reboot.Loop ? partialResponse : {% endif %}{{ state.proto.name }}{{ method.proto.name }}ResponseToProtobuf(partialResponse);

      {% if options.proto.zod and method.options.proto.kind != 'workflow' %}
      // Validate and convert back to protobuf when using Zod.
      state = {{ state.proto.name }}ToProtobuf(state);
      {% endif %}

      {% if method.options.proto.kind == 'writer' %}
      // TODO: it's premature to overwrite the state now given that the
      // writer might still "fail" and an error will get propagated back
      // to the ongoing transaction which will still see the effects of
      // this writer. What we should be doing instead is creating a
      // callback API that we invoke only after a writer completes
      // that lets us update the state _reference_ then.
      if (context.stateId in ongoingTransactionStates) {
        ongoingTransactionStates[context.stateId].copyFrom(state);
      }
      {% elif method.options.proto.kind == 'transaction' %}
      delete ongoingTransactionStates[context.stateId];
      {% endif %}
      return JSON.stringify(
        {
          {% if method.options.proto.kind in ['writer', 'transaction'] %}
          effects: {
            state: state.toJson(),
            response: response.toJson(),
          },
          {% elif method.options.proto.kind == 'workflow' %}
          ...(response instanceof reboot.Loop
              && { loop: { when: response.when } }
              ||  { response: response.toJson() }),
          {% else %}
          response: response.toJson()
          {% endif %}
        }
      );
    } catch (e) {
      if (e instanceof reboot_api.Aborted) {
        return JSON.stringify({
          status: e.toStatus()
        });
      }

      // Ensure we have an `Error` and then `console.error()` it so
      // that developers see a stack trace of what is going on.
      //
      // Only do this if it IS NOT an `Aborted` which we handle above.
      const error = ensureError(e);
      // Write an empty message which includes a newline to make it
      // easier to identify the stack trace.
      console.error("");
      console.error(error);
      console.error("");
      console.error(
        `Unhandled error in '{{ proto.package_name }}.{{ state.proto.name }}.{{ method.proto.name | to_lower_camel }}'; propagating as 'Unknown'\n`
      );

      throw error;
    }
  }

  {% endfor %}
  {% endfor %}

  __storeExternal(external: any) {
    this.#external = external;
  }

  get __external() {
    if (this.#external === undefined) {
      throw new Error(`Unexpected undefined external`);
    }
    return this.#external;
  }

  authorizer(): reboot.Authorizer<{{ state.proto.name }}.State, {{ state.proto.name }}RequestTypes> | reboot.AuthorizerRule<{{ state.proto.name }}.State, {{ state.proto.name }}RequestTypes> | null {
    return null;
  }

  _authorizer() {
    // Get authorizer, if any, converting from a rule if necessary.
    const authorizer = ((authorizerOrRule) => {
      if (authorizerOrRule instanceof reboot.AuthorizerRule) {
        return new {{ state.proto.name }}Authorizer({ _default: authorizerOrRule });
      }
      return authorizerOrRule;
    })(this.authorizer());

    if (authorizer !== null) {
      authorizer._authorize = async function(
        methodName: string,
        context: ReaderContext,
        bytesState?: Uint8Array,
        bytesRequest?: Uint8Array
      ): Promise<Uint8Array> {
        const anyRequest = protobuf_es.Any.fromBinary(bytesRequest);
        {% set ns = namespace(nested_loop_first = true) %}
        {% for service in state.services %}
        {% for method in service.methods %}
        {% if ns.nested_loop_first %}
        {% set ns.nested_loop_first = false %}
        if (anyRequest.is({{ method.input_type }})) {
        {% else %}
        } else if (anyRequest.is({{ method.input_type }})) {
        {% endif %}
          const unpackedRequest = new {{ method.input_type }}();
          anyRequest.unpackTo(unpackedRequest);
          try {
            // NOTE: we are setting `state` within `try` so that any
            // possible validation errors if using Zod are logged in
            // the `catch`.
            const state: {{ state.proto.name }}.State | undefined =
              bytesState && {{ state.proto.name }}FromBinary(bytesState);
            const request = {{ state.proto.name }}{{ method.proto.name }}RequestFromProtobufShape(unpackedRequest);
            return protobuf_es.Any.pack(
              await authorizer.authorize(methodName, context, state, request)
            ).toBinary();
          } catch (e) {
            // Ensure we have an `Error` and then `console.error()` it so
            // that developers see a stack trace of what is going on.
            const error = ensureError(e);
            // Write an empty message which includes a newline to make it
            // easier to identify the stack trace.
            console.error("");
            console.error(error);
            console.error("");
            console.error(
              `Unhandled error trying to authorize '{{ state.proto.name }}.{{ method.proto.name | to_lower_camel }}'\n`
            );

            throw error;
          }
        {% endfor %}
        {% endfor %}
        } else {
          throw new Error(`Unexpected type for ${request}: ${anyRequest.typeUrl}.`);
        }
      };
    }
    return authorizer;
  }

  static WorkflowState = class {

    #servicer: {{ state.proto.name }}Servicer

    constructor(servicer: {{ state.proto.name }}Servicer) {
      this.#servicer = servicer;
    }

    async read(
      context: reboot.WorkflowContext
    ): Promise<{{ state.proto.name }}.State> {
      return {{ state.proto.name }}FromJsonString(
        await reboot_native.Servicer_read(
          this.#servicer.__external,
          context.__external
        )
      );
    }

    async write(
      idempotencyAlias: string,
      context: reboot.WorkflowContext,
      writer: (state: {{ state.proto.name }}.State) => Promise<void>,
      options?: {
        stringify?: undefined;
        parse?: undefined;
        validate?: undefined
      }
    ): Promise<void>;

    async write<T>(
      idempotencyAlias: string,
      context: reboot.WorkflowContext,
      writer: (state: {{ state.proto.name }}.State) => Promise<T>,
      options: {
        stringify?: (result: T) => string;
        parse: (value: string) => T;
        validate?: undefined;
      } | {
        stringify?: (result: T) => string;
        parse?: undefined;
        validate: (result: T) => boolean;
      }
    ): Promise<T>;

    async write<T>(
      idempotencyAlias: string,
      context: reboot.WorkflowContext,
      writer: (state: {{ state.proto.name }}.State) => Promise<T>,
      options: {
        stringify?: (result: T) => string;
        parse?: (value: string) => T;
        validate?: (result: T) => boolean
      } = {}
    ): Promise<void | T> {
      return await this.idempotently(idempotencyAlias)
        .write(context, writer, options);
    }

    static _Idempotently = class {

      #external: any;
      #options: reboot_api.IdempotencyOptions;

      constructor(external: any, options: reboot_api.IdempotencyOptions) {
        this.#external = external;
        this.#options = options;
      }

      async write(
        context: reboot.WorkflowContext,
        writer: (state: {{ state.proto.name }}.State) => Promise<void>,
        options?: {
          stringify?: undefined;
          parse?: undefined;
          validate?: undefined
        },
        unidempotently?: boolean
      ): Promise<void>;

      async write<T>(
        context: reboot.WorkflowContext,
        writer: (state: {{ state.proto.name }}.State) => Promise<T>,
        options: {
          stringify?: (result: T) => string;
          parse: (value: string) => T;
          validate?: undefined;
        } | {
          stringify?: (result: T) => string;
          parse?: undefined;
          validate: (result: T) => boolean;
        },
        unidempotently?: boolean
      ): Promise<T>;

      async write<T>(
        context: reboot.WorkflowContext,
        writer: (state: {{ state.proto.name }}.State) => Promise<T>,
        {
          stringify,
          parse,
          validate
        }: {
          stringify?: (result: T) => string;
          parse?: (value: string) => T;
          validate?: (result: T) => boolean
        },
        unidempotently: boolean = false,
      ): Promise<void | T> {
        // Use `JSON.stringify` and `JSON.parse` by default.
        stringify = stringify ?? JSON.stringify;
        parse = parse ?? JSON.parse;

        const result = await reboot_native.Servicer_write(
          this.#external,
          context.__external,
          async (jsonState: string) => {
            const state = {{ state.proto.name }}FromJsonString(
              jsonState
            );
            try {
              const t = await writer(state);

              // Fail early if the developer thinks that they have some value
              // that they want to validate but we got `undefined`.
              if (t === undefined && validate !== undefined) {
                throw new Error(
                  "Not expecting `validate` as you are returning `void` (or explicitly `undefined`); did you mean to return a value (or if you want to explicitly return the absence of a value use `null`)"
                );
              }

              return JSON.stringify({
                // NOTE: we use the empty string to represent a
                // `callable` returning `void` (or explicitly
                // `undefined`).
                //
                // To differentiate returning `void` (or explicitly
                // `undefined`) from `stringify` returning an empty
                // string we use `{ value: stringify(t) }`.
                result: (
                  t !== undefined && JSON.stringify({ value: stringify(t) })
                ) || "",
                state: {{ state.proto.name }}ToProtobuf(state).toJson(),
              });
            } catch (e) {
              throw ensureError(e);
            }
          },
          JSON.stringify({ idempotency: this.#options, unidempotently }),
        );

        // NOTE: we parse and validate `value` every time, even the first
        // time, so as to catch bugs where the `value` returned from
        // `callable` might not parse or be valid. We will have already
        // persisted `result`, so in the event of a bug the developer will
        // have to change the idempotency alias so that `callable` is
        // re-executed. These semantics are the same as Python (although
        // Python uses the `type` keyword argument instead of the
        // `parse` and `validate` properties we use here).

        // TODO: reboot_api.assert(result !== undefined);

        if (result !== "") {
          const { value } = JSON.parse(result);
          const t = parse(value);
          if (!unidempotently) {
            if (parse !== JSON.parse) {
              if (validate === undefined) {
                throw new Error("Missing `validate` property");
              } else if (!validate(t)) {
                throw new Error("Failed to validate memoized result");
              }
            }
          }
          return t;
        }

        // TODO: reboot_api.assert(result === "");

        // Otherwise `callable` must have returned void (or explicitly
        // `undefined`), fall through.
      }
    };

    public idempotently(aliasOrOptions: string | reboot_api.IdempotencyOptions) {
      const options = (typeof aliasOrOptions === "string" || aliasOrOptions instanceof String)
        ? { alias: aliasOrOptions }
        : aliasOrOptions;
      if (options.alias === undefined && options.key === undefined) {
        throw new Error(
          "Inline writers require either an idempotency alias or key"
        );
      }
      return new {{ state.proto.name }}Servicer.WorkflowState._Idempotently(
        this.#servicer.__external,
        options,
      );
    }

    static _Unidempotently = class {

      #external: any;

      constructor(external: any) {
        this.#external = external;
      }

      async write(
        context: reboot.WorkflowContext,
        writer: (state: {{ state.proto.name }}.State) => Promise<void>
      ): Promise<void>;

      async write<T>(
        context: reboot.WorkflowContext,
        writer: (state: {{ state.proto.name }}.State) => Promise<T>
      ): Promise<T>;

      async write<T>(
        context: reboot.WorkflowContext,
        writer: (state: {{ state.proto.name }}.State) => Promise<T>
      ): Promise<T> {
        return new {{ state.proto.name }}Servicer.WorkflowState._Idempotently(
          this.#external,
          { key: uuid.v4() }
        ).write<T>(
          context,
          writer,
          {},
          true
        );
      }
    };

    public unidempotently() {
      return new {{ state.proto.name }}Servicer.WorkflowState._Unidempotently(
        this.#servicer.__external
      );
    }
  };

  get state() {
    return new {{ state.proto.name }}Servicer.WorkflowState(this);
  }
}

export type {{ state.proto.name }}AuthorizerRules = {
  {% for service in state.services %}
  {% for method in service.methods %}
  {{ method.proto.name | to_lower_camel }}?: reboot.AuthorizerRule<{{ state.proto.name }}.State, {{ state.proto.name }}.{{ method.proto.name }}Request>;
  {% endfor %}
  {% endfor %}
};

export class {{ state.proto.name }}Authorizer extends reboot.Authorizer<{{ state.proto.name }}.State, {{ state.proto.name }}RequestTypes> {

  #rules: {{ state.proto.name }}AuthorizerRules & {
    _default: reboot.AuthorizerRule<{{ state.proto.name }}.State, protobuf_es.Message>;
  };

  constructor(
    rules?: {{ state.proto.name }}AuthorizerRules & {
      _default?: reboot.AuthorizerRule<{{ state.proto.name }}.State, protobuf_es.Message>;
    }
  ) {
    super();
    this.#rules = { ...rules, _default: rules?._default ?? reboot.allowIf({ all: [ reboot.isAppInternal ] }) };
  }

  async authorize(
    methodName: string,
    context: ReaderContext,
    state?: {{ state.proto.name }}.State,
    request?: {{ state.proto.name }}RequestTypes
  ): Promise<reboot.AuthorizerDecision> {
    {% set ns = namespace(nested_loop_first = true) %}
    {% for service in state.services %}
    {% for method in service.methods %}
    {% if ns.nested_loop_first %}
    {% set ns.nested_loop_first = false %}
    if (methodName == '{{ method.proto.full_name }}') {
    {% else %}
    } else if (methodName == '{{ method.proto.full_name }}') {
    {% endif %}
      return await this.{{ method.proto.name | to_lower_camel }}(
        context,
        {% if not method.options.proto.constructor %}
        state,
        {% endif %}
        {% if not (method.options.proto.kind == 'reader' and method.proto.client_streaming) %}
        request as {{ state.proto.name }}.{{ method.proto.name }}Request,
        {% endif %}
      );
    {% endfor %}
    {% endfor %}
    } else {
      return new reboot_api.errors_pb.PermissionDenied();
    }
  }

  {% for service in state.services %}
  {% for method in service.methods %}
  async {{ method.proto.name | to_lower_camel }}(
    context: ReaderContext,
    {% if not method.options.proto.constructor %}
    state: {{ state.proto.name }}.State,
    {% endif %}
    {% if not (method.options.proto.kind == 'reader' and method.proto.client_streaming) %}
    request: {{ state.proto.name }}.{{ method.proto.name }}Request,
    {% endif %}
  ): Promise<reboot.AuthorizerDecision> {
    return await (
      this.#rules.{{ method.proto.name | to_lower_camel }} ?? this.#rules._default
    ).execute({
      context,
      {% if not method.options.proto.constructor %}
      state,
      {% endif %}
      {% if not (method.options.proto.kind == 'reader' and method.proto.client_streaming) %}
      request: request as {{ state.proto.name }}.{{ method.proto.name }}Request,
      {% endif %}
    });
  }
  {% endfor %}
  {% endfor %}
}

{% endfor %}
{# End generated Servicer code #}
{# Start generated State code #}
{% for state in states %}

export class {{ state.proto.name }}State extends {{ state.proto.name }}Proto {

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<protobuf_es.BinaryReadOptions>
  ) {
    const state = new {{ state.proto.name }}State();
    state.fromBinary(bytes, options);
    return state;
  }

  static fromJson(
    jsonValue: protobuf_es.JsonValue,
    options?: Partial<protobuf_es.JsonReadOptions>
  ) {
    const state = new {{ state.proto.name }}State();
    state.fromJson(jsonValue, options);
    return state;
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<protobuf_es.JsonReadOptions>
  ) {
    const state = new {{ state.proto.name }}State();
    state.fromJsonString(jsonString, options);
    return state;
  }

  public clone() {
    const state = new {{ state.proto.name }}State();
    state.copyFrom(super.clone());
    return state;
  }

  public copyFrom(that: {{ state.proto.name }}State | {{ state.proto.name }}Proto) {
    // Unfortunately, protobuf-es does not have `CopyFrom` like Python
    // or C++ protobuf. Instead, protobuf-es has `fromJson` but it
    // performs a merge. Thus, we have to first clear all of the fields
    // in the message before calling `fromJson`.
    reboot.clearFields(this);
    this.fromJson(that.toJson());
  }
}

{% endfor %}

{% for client in clients %}

{% for service in client.services %}
{% for method in service.methods %}

{% if options.proto.zod %}
{% if method.options.errors | length != 0 %}
const {{ client.proto.state_name }}{{ method.proto.name }}ErrorsSchema: typeof api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors extends z.ZodDiscriminatedUnion ? typeof api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors : ReturnType<typeof z.discriminatedUnion<typeof api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors>> =
  api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors instanceof z.ZodDiscriminatedUnion
    ? api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors
    // In order to types to properly be exposed
    // 'api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors' must be defined with `as const`.
    //
    // TODO: eliminate this requirement for developers by indexing
    // all of the errors in the code generation since we can determine
    // how many there are.
    : z.discriminatedUnion("type", api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors);
{% endif %}
{% endif %}

export class {{ client.proto.state_name }}{{ method.proto.name }}Aborted extends reboot_api.Aborted {
  static fromStatus(status: reboot_api.Status) {
    let error = reboot_api.errorFromGoogleRpcStatusDetails(
      status,
      {{ client.proto.state_name | to_screaming_snake }}_{{ method.proto.name | to_screaming_snake }}_ERROR_TYPES,
    );

    if (error !== undefined) {
      return new {{ client.proto.state_name | to_camel }}.{{ method.proto.name | to_camel }}Aborted(
        error, { message: status.message }
      );
    }

    error = reboot_api.errorFromGoogleRpcStatusCode(status);

    // TODO(benh): also consider getting the type names from
    // `status.details` and including that in `message` to make
    // debugging easier.

    return new {{ client.proto.state_name | to_camel }}.{{ method.proto.name | to_camel }}Aborted(
      error, { message: status.message }
    );
  }

  public toStatus(): reboot_api.Status {
    const isObject = (value: unknown): value is object => {
      return typeof value === 'object';
    };

    const isArray = (value: unknown): value is any[]  => {
      return Array.isArray(value);
    };

    const error = this.#error.toJson();

    if (!isObject(error) || isArray(error)) {
      throw new Error("Expecting 'error' to be an object (and not an array)");
    }

    const detail = { ...error };
    detail["@type"] = `type.googleapis.com/${this.#error.getType().typeName}`;

    return new reboot_api.Status({
      code: this.code,
      message: this.#message,
      details: [detail]
    });
  }

  constructor(
    error: {{ client.proto.state_name | to_camel }}{{ method.proto.name | to_camel }}AbortedError{% if options.proto.zod %}{% if method.options.errors | length != 0 %} | z.infer<typeof {{ client.proto.state_name }}{{ method.proto.name }}ErrorsSchema>{% endif %} | z.infer<typeof reboot_api.ZOD_ERRORS>{% endif %},
    { message }: { message?: string } = {}
  ) {
    super();

    // Set the name of this error for even more information!
    this.name = this.constructor.name;

    {% if options.proto.zod %}
    if (error instanceof protobuf_es.Message) {
      this.#error = error;
    } else if (!("type" in error)) {
      throw new Error("Expecting discriminator 'type' in error");
    } else if (reboot_api.ZOD_ERROR_NAMES.includes(error.type)) {
      this.#error = reboot_api.errorFromZodError(error);
    } else {
      {% if method.options.errors | length != 0 %}
      this.#error = {{ pb_name }}.{{ client.proto.state_name }}{{ method.proto.name }}Errors.fromJson(
        reboot_api.convertToProtobufJson(
          {{ client.proto.state_name }}{{ method.proto.name }}ErrorsSchema,
          reboot_api.validate(
            "api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.errors",
            {{ client.proto.state_name }}{{ method.proto.name }}ErrorsSchema,
            error
          )
        )
      );
      {% else %}
      throw new Error(`Unknown 'type' discriminator '${error.type}' in error`);
      {% endif %}
    }
    {% else %}
    this.#error = error;
    {% endif %}

    let code = reboot_api.grpcStatusCodeFromError(this.#error);

    if (code === undefined) {
      // Must be one of the Reboot specific errors.
      code = reboot_api.StatusCode.ABORTED;
    }

    this.code = code;

    this.#message = message;
  }

  toString(): string {
    return `${this.name}: ${this.message}`;
  }

  get message(): string {
    return `${this.#error.getType().typeName}${this.#message ? ": " + this.#message : ""}`;
  }

  get error(){% if options.proto.zod %}: {% if method.options.errors | length != 0 %}z.infer<typeof {{ client.proto.state_name }}{{ method.proto.name }}ErrorsSchema> | {% endif %}z.infer<typeof reboot_api.ZOD_ERRORS>{% endif %} {
    reboot_api.assert(this.#error instanceof protobuf_es.Message);
    {% if options.proto.zod %}
    {% if method.options.errors | length != 0 %}
    if (this.#error instanceof {{ pb_name }}.{{ client.proto.state_name }}{{ method.proto.name }}Errors) {
      return reboot_api.convertFromProtobuf(
        {{ client.proto.state_name }}{{ method.proto.name }}ErrorsSchema,
        this.#error
      );
    }
    {% else %}
    return reboot_api.zodErrorFromError(this.#error);
    {% endif %}
    {% else %}
    return this.#error;
    {% endif %}
  }

  readonly #error: {{ client.proto.state_name | to_camel }}{{ method.proto.name | to_camel }}AbortedError;
  readonly code: reboot_api.StatusCode;
  readonly #message?: string;
}

export class {{ client.proto.state_name }}{{ method.proto.name }}Task {

  readonly taskId: reboot_api.tasks_pb.TaskId;

  #promise: Promise<{{ client.proto.state_name }}.{{ method.proto.name }}Response>;

  private constructor(
    context: reboot.WorkflowContext | reboot.ExternalContext,
    taskId: reboot_api.tasks_pb.TaskId
  ) {
    this.taskId = taskId;
    this.#promise = new Promise(async (resolve, reject) => {
      const json = JSON.parse(
        await reboot_native.Task_await({
          context: context.__external,
          rbtModule: "{{ rbt_name }}",
          stateName: "{{ client.proto.state_name }}",
          method: "{{ method.proto.name }}",
          jsonTaskId: JSON.stringify(taskId),
        })
      );

      if ("status" in json) {
        reject(
          {{ client.proto.state_name }}
            .{{ method.proto.name }}Aborted
            .fromStatus(reboot_api.Status.fromJson(json["status"]))
        );
      } else {
        reboot_api.assert("response" in json);
        resolve(
          {{ client.proto.state_name }}{{ method.proto.name }}ResponseFromProtobufShape(json["response"])
        );
      }
    });
  }

  static retrieve(
    context: reboot.WorkflowContext | reboot.ExternalContext,
    { taskId }: { taskId: reboot_api.tasks_pb.TaskId }
  ) {
    return new {{ client.proto.state_name }}{{ method.proto.name }}Task(
      context, taskId
    );
  }

  then(...args: Parameters<Promise<{{ client.proto.state_name }}.{{ method.proto.name }}Response>["then"]>) {
    return this.#promise.then(...args);
  }
}

{% endfor %}
{% endfor %}

{% endfor %}

{% for client in clients %}

export class {{ client.proto.state_name }}WeakReference {
  #external: any;
  #id: string;
  #options?: reboot_api.CallOptions;

  constructor(id: string, bearerToken?: string) {
    this.#id = id;
    this.#options = {
      bearerToken: bearerToken,
    };
    this.#external = reboot_native.Service_constructor({
      rbtModule: "{{ rbt_name }}",
      nodeAdaptor: "{{ client.proto.state_name }}WeakReferenceNodeAdaptor",
      id: this.#id,
    });
  }

  get stateId(): string {
    return this.#id;
  }

  {% for service in client.services %}
  {% for method in service.methods %}
  async __externalServiceCall{{ method.proto.name }}(
    context: Context | ExternalContext,
    partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    options?: reboot_api.CallOptions
  ): Promise<any> {
    const request = {{ client.proto.state_name }}{{ method.proto.name }}RequestToProtobuf(partialRequest);

    const json = JSON.parse(
      await reboot_native.Service_call({
        external: this.#external,
        kind: "{{ method.options.proto.kind }}",
        method: "{{ method.proto.name }}",
        requestModule: "{{ method.python_request_message_module }}",
        requestType: "{{ method.python_input_type }}",
        context: context.__external,
        jsonRequest: JSON.stringify(request.toJson() || {}),
        jsonOptions: JSON.stringify(options || {}),
      })
    );

    if ("status" in json) {
      throw {{ client.proto.state_name }}
        .{{ method.proto.name }}Aborted
        .fromStatus(reboot_api.Status.fromJson(json["status"]));
    } else if ("taskId" in json) {
      return reboot_api.tasks_pb.TaskId.fromJson(json["taskId"]);
    } else {
      reboot_api.assert("response" in json);
      return {{ client.proto.state_name }}{{ method.proto.name }}ResponseFromProtobufShape(json["response"]);
    }
  }

  {% if not method.options.proto.constructor %}
  {% if method.options.proto.kind == 'workflow' %}
  async {{ method.proto.name | to_lower_camel }}(
    context: ExternalContext,
    partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
  ): Promise<{{ client.proto.state_name }}.{{ method.proto.name }}Response> {
    const { task } = await this.spawn()
      .{{ method.proto.name | to_lower_camel }}(context, partialRequest);
    return await task;
  }
  {% else %}
  async {{ method.proto.name | to_lower_camel }}(
    {% if method.options.proto.kind == 'reader' %}
    context: ReaderContext | WriterContext | TransactionContext | WorkflowContext | ExternalContext,
    {% elif method.options.proto.kind in ['writer', 'transaction'] %}
    context: TransactionContext | WorkflowContext | ExternalContext,
    {% endif %}
    partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
  ): Promise<{{ client.proto.state_name }}.{{ method.proto.name }}Response> {
    return await this.__externalServiceCall{{ method.proto.name }}(
      context,
      partialRequest,
      this.#options,
    );
  }
  {% endif %}

  {% endif %}
  {% endfor %}
  {% endfor %}

  static _Idempotently = class {

    #weakReference: any;
    #options: reboot_api.CallOptions;

    constructor(
      weakReference: any,
      options: reboot_api.CallOptions
    ) {
      this.#weakReference = weakReference;
      this.#options = options;
    }

    {% for service in client.services %}
    {% for method in service.methods %}
    {% if method.options.proto.kind in ['workflow'] %}
    async {{ method.proto.name | to_lower_camel }}(
      context: reboot.WorkflowContext | reboot.ExternalContext,
      partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    ): Promise<{{ client.proto.state_name }}.{{ method.proto.name }}Response> {
      const { task } = await this.spawn()
        .{{ method.proto.name | to_lower_camel }}(context, partialRequest);
      return await task;
    }
    {% elif method.options.proto.kind in ['writer', 'transaction'] and not method.options.proto.constructor %}
    async {{ method.proto.name | to_lower_camel }}(
      context: reboot.TransactionContext | reboot.WorkflowContext | reboot.ExternalContext,
      partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    ): Promise<{{ client.proto.state_name }}.{{ method.proto.name }}Response> {
      return await this.#weakReference.__externalServiceCall{{ method.proto.name }}(
        context,
        partialRequest,
        this.#options,
      );
    }

    {% endif %}
    {% endfor %}
    {% endfor %}

    public schedule(options?: reboot_api.ScheduleOptions) {
      return new {{ client.proto.state_name }}.WeakReference._Schedule(
        this.#weakReference,
        {
          ...this.#options,
          schedule: options || { when: new Date() }
        },
      );
    }

    public spawn(options?: reboot_api.ScheduleOptions) {
      return new {{ client.proto.state_name }}.WeakReference._Spawn(
        this.#weakReference,
        {
          ...this.#options,
          schedule: options || { when: new Date() }
        },
      );
    }
  };

  public idempotently(aliasOrOptions: string | reboot_api.IdempotencyOptions = {} as reboot_api.IdempotencyOptions) {
    const idempotency = (typeof aliasOrOptions === "string" || aliasOrOptions instanceof String) ? { alias: aliasOrOptions } : aliasOrOptions;
    return new {{ client.proto.state_name }}.WeakReference._Idempotently(
      this,
      {
        ...this.#options,
        idempotency: idempotency,
      },
    );
  }

  public unidempotently() {
    return this.idempotently({ key: uuid.v4() });
  }

  static _Schedule = class {

    #weakReference: any;
    #options: reboot_api.CallOptions;

    constructor(
      weakReference: any,
      options: reboot_api.CallOptions,
    ) {
      this.#weakReference = weakReference;
      this.#options = options;
    }

    {% for service in client.services %}
    {% for method in service.methods %}
    {% if not method.options.proto.constructor %}
    async {{ method.proto.name | to_lower_camel }}(
      context: reboot.WriterContext | reboot.TransactionContext,
      partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    ): Promise<reboot_api.tasks_pb.TaskId> {
      return await this.#weakReference.__externalServiceCall{{ method.proto.name }}(
        context,
        partialRequest,
        this.#options,
      );
    }

    {% endif %}
    {% endfor %}
    {% endfor %}

  };

  public schedule(options?: reboot_api.ScheduleOptions) {
    return new {{ client.proto.state_name }}.WeakReference._Schedule(
      this,
      {
        ...this.#options,
        schedule: options || { when: new Date() }
      },
    );
  }

  static _Spawn = class {

    #weakReference: any;
    #options: reboot_api.CallOptions;

    constructor(
      weakReference: any,
      options: reboot_api.CallOptions,
    ) {
      this.#weakReference = weakReference;
      this.#options = options;
    }

    {% for service in client.services %}
    {% for method in service.methods %}
    {% if not method.options.proto.constructor %}
    async {{ method.proto.name | to_lower_camel }}(
      context: reboot.WorkflowContext | reboot.ExternalContext,
      partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    ): Promise<{ task: {{ client.proto.state_name }}{{ method.proto.name }}Task }> {
      const taskId = await this.#weakReference.__externalServiceCall{{ method.proto.name }}(
        context,
        partialRequest,
        this.#options,
      );

      return {
        task: {{ client.proto.state_name }}.{{ method.proto.name }}Task
          .retrieve(context, { taskId })
      };
    }

    {% endif %}
    {% endfor %}
    {% endfor %}

  };

  public spawn(options?: reboot_api.ScheduleOptions) {
    return new {{ client.proto.state_name }}.WeakReference._Spawn(
      this,
      {
        ...this.#options,
        schedule: options || { when: new Date() }
      },
    );
  }
}

export class {{ client.proto.state_name }} {

  {% if client.state is not none %}
  static Servicer = {{ client.proto.state_name }}Servicer;
  static servicer = {{ client.proto.state_name }}Servicer.servicer;
  static State = {{ client.proto.state_name }}State;
  static Authorizer = {{ client.proto.state_name }}Authorizer;
  {% endif %}
  static WeakReference = {{ client.proto.state_name }}WeakReference;

  {% for service in client.services %}
  {% for method in service.methods %}

  static {{ method.proto.name }}Aborted = {{ client.proto.state_name }}{{ method.proto.name }}Aborted;

  static {{ method.proto.name }}Task = {{ client.proto.state_name }}{{ method.proto.name }}Task;

  {% endfor %}
  {% endfor %}

  public static ref(
    idOrOptions?: string | { bearerToken?: string },
    options?: { bearerToken?: string }
  ) {
    if (idOrOptions === undefined || typeof idOrOptions === "object") {
      const context = reboot.getContext();
      return new {{ client.proto.state_name }}.WeakReference(context.stateId, idOrOptions?.bearerToken);
    }
    if (typeof idOrOptions !== "string") {
      throw new TypeError(
        `Expecting first argument to be a 'string' "id", ` +
        `got '${typeof idOrOptions}'`
      );
    }
    return new {{ client.proto.state_name }}.WeakReference(idOrOptions, options?.bearerToken);
  }

  {% for service in client.services %}
  {% for method in service.methods %}
  {%- if method.options.proto.kind == 'workflow' %}
  {# TODO(benh): support constructor "tasks" and workflows. #}
  {%- else %}
  {% if method.options.proto.constructor %}
  public async {{ method.proto.name | to_lower_camel }}(
    context: reboot.TransactionContext | reboot.WorkflowContext | reboot.ExternalContext,
    partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    options?: { bearerToken?: string }
  ): Promise<[
    {{ client.proto.state_name }}.WeakReference,
    {{ client.proto.state_name }}.{{ method.proto.name }}Response,
  ]>;

  public async {{ method.proto.name | to_lower_camel }}(
    context: reboot.TransactionContext | reboot.WorkflowContext | reboot.ExternalContext,
    id: string,
    partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    options?: { bearerToken?: string }
  ): Promise<[
    {{ client.proto.state_name }}.WeakReference,
    {{ client.proto.state_name }}.{{ method.proto.name }}Response,
  ]>;

  public static async {{ method.proto.name | to_lower_camel }}(
    context: reboot.TransactionContext | reboot.WorkflowContext | reboot.ExternalContext,
    idOrPartialRequest?: string | {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
    partialRequestOrOptions?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request | { bearerToken?: string },
    optionsOrUndefined?: { bearerToken?: string }
  ): Promise<[
    {{ client.proto.state_name }}.WeakReference,
    {{ client.proto.state_name }}.{{ method.proto.name }}Response,
  ]> {
    let id: string | undefined = undefined;
    let partialRequest: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request | undefined = undefined;
    let options: { bearerToken?: string } | undefined = undefined;

    if (typeof idOrPartialRequest === "string" || idOrPartialRequest instanceof String) {
      id = idOrPartialRequest;
      partialRequest = partialRequestOrOptions;
      options = optionsOrUndefined;
    } else {
      partialRequest = idOrPartialRequest;
      options = partialRequestOrOptions;
      if (optionsOrUndefined !== undefined) {
        throw new Error(
          `Invalid arguments passed to '{{ client.proto.state_name }}.{{ method.proto.name | to_lower_camel }}'`
        );
      }
    }

    if (id === undefined) {
      id = uuid.v4();
    }

    const weakReference = {{ client.proto.state_name }}.ref(id);

    const response = await weakReference.__externalServiceCall{{ method.proto.name }}(
      context,
      partialRequest,
      options,
    );

    return [
      weakReference,
      response,
    ];
  }

  {% endif %}
  {% endif %}
  {% endfor %}
  {% endfor %}

  public static idempotently(aliasOrOptions: string | reboot_api.IdempotencyOptions = {} as reboot_api.IdempotencyOptions) {
    const idempotency = (typeof aliasOrOptions === "string" || aliasOrOptions instanceof String) ? { alias: aliasOrOptions } : aliasOrOptions;
    return new {{ client.proto.state_name }}._ConstructIdempotently(idempotency);
  }

  static _ConstructIdempotently = class {
    #idempotency: reboot_api.IdempotencyOptions;

    constructor(idempotency: reboot_api.IdempotencyOptions) {
      this.#idempotency = idempotency;
    }

    {% for service in client.services %}
    {% for method in service.methods %}
    {%- if method.options.proto.kind == 'workflow' %}
    {# TODO(benh): support constructor "tasks" and workflows. #}
    {%- else %}
    {% if method.options.proto.constructor %}
    public async {{ method.proto.name | to_lower_camel }}(
      context: reboot.TransactionContext | reboot.WorkflowContext | reboot.ExternalContext,
      partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
      options?: { bearerToken?: string }
    ): Promise<[
      {{ client.proto.state_name }}.WeakReference,
      {{ client.proto.state_name }}.{{ method.proto.name }}Response,
    ]>;

    public async {{ method.proto.name | to_lower_camel }}(
      context: reboot.TransactionContext | reboot.WorkflowContext | reboot.ExternalContext,
      id: string,
      partialRequest?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
      options?: { bearerToken?: string }
    ): Promise<[
      {{ client.proto.state_name }}.WeakReference,
      {{ client.proto.state_name }}.{{ method.proto.name }}Response,
    ]>;

    public async {{ method.proto.name | to_lower_camel }}(
      context: reboot.TransactionContext | reboot.WorkflowContext | reboot.ExternalContext,
      idOrPartialRequest?: string | {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request,
      partialRequestOrOptions?: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request | { bearerToken?: string },
      optionsOrUndefined?: { bearerToken?: string }
    ): Promise<[
      {{ client.proto.state_name }}.WeakReference,
      {{ client.proto.state_name }}.{{ method.proto.name }}Response,
    ]> {
      let id: string | undefined = undefined;
      let partialRequest: {{ client.proto.state_name }}.Partial{{ method.proto.name }}Request | undefined = undefined;
      let options: { bearerToken?: string } = {};

      if (typeof idOrPartialRequest === "string" || idOrPartialRequest instanceof String) {
        id = idOrPartialRequest;
        partialRequest = partialRequestOrOptions;
        options = optionsOrUndefined;
      } else {
        partialRequest = idOrPartialRequest;
        options = partialRequestOrOptions;
        if (optionsOrUndefined !== undefined) {
          throw new Error(
            `Not expecting more than 'partialRequest' and 'options' arguments after 'context'`
          );
        }
      }

      if (id === undefined) {
        id = await context.generateIdempotentStateId(
          "{{ proto.package_name }}.{{ client.proto.state_name }}",
          "{{ service.proto.full_name }}",
          "{{ method.proto.name }}",
          this.#idempotency,
        ) as string;
      }

      return await {{ client.proto.state_name }}.{{ method.proto.name | to_lower_camel }}(
        context,
        id,
        partialRequest,
        {
          ...options,
          idempotency: this.#idempotency,
        },
      );
    }

    {% endif %}
    {% endif %}
    {% endfor %}
    {% endfor %}
  };
}

{% for service in client.services %}
{% for method in service.methods %}
export namespace {{ client.proto.state_name }} {
  export type {{ method.proto.name }}Aborted = typeof {{ client.proto.state_name }}.{{ method.proto.name }}Aborted.prototype;

  export type {{ method.proto.name }}Request =
    {% if options.proto.zod %}
    z.infer<
      reboot_api.EnsureZodObject<
        typeof api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.request
      >
    >;
    {% else %}
    {{ method.input_type }};
    {% endif %}

  export type Partial{{ method.proto.name }}Request =
    {% if options.proto.zod %}
    {{ method.proto.name }}Request;
    {% else %}
    protobuf_es.PartialMessage<{{ method.input_type }}>;
    {% endif %}

  export type {{ method.proto.name }}Response =
    {% if options.proto.zod %}
    z.infer<
      reboot_api.EnsureZodObject<
        typeof api.{{ client.proto.state_name }}.methods.{{ method.proto.name | to_lower_camel }}.response
      >
    >;
    {% else %}
    {{ method.output_type }};
    {% endif %}

  export type Partial{{ method.proto.name }}Response =
    {% if options.proto.zod %}
    {{ method.proto.name }}Response;
    {% else %}
    protobuf_es.PartialMessage<{{ method.output_type }}>;
    {% endif %}
}
{% endfor %}
{% endfor %}

{% for service in client.services %}
{% for method in service.methods if method.options.proto.kind in ['writer', 'transaction'] %}
export namespace {{ client.proto.state_name }} {
  export type {{ method.proto.name }}Task = typeof {{ client.proto.state_name }}.{{ method.proto.name }}Task.prototype;
  {% if client.state is not none %}
  {% endif %}
}
{% endfor %}
{% endfor %}

{% for service in client.services %}
{% for method in service.methods if method.options.proto.kind in ['workflow'] %}
export namespace {{ client.proto.state_name }} {
  export type {{ method.proto.name }}Task = typeof {{ client.proto.state_name }}.{{ method.proto.name }}Task.prototype;
}
{% endfor %}
{% endfor %}

export namespace {{ client.proto.state_name }} {
  export type RequestTypes = {{ client.proto.state_name }}RequestTypes;
  export type WeakReference = {{ client.proto.state_name }}WeakReference;
  {% if client.state is not none %}
  export type State =
  {% if options.proto.zod %}
    z.infer<
      reboot_api.EnsureZodObject<
        typeof api.{{ client.proto.state_name }}.state
      >
    >;
  {% else %}
    {{ client.proto.state_name }}State;
  {% endif %}

  export type WorkflowState = InstanceType<
    typeof {{ client.proto.state_name }}Servicer.WorkflowState
  >;
  {% endif %}
}
{% endfor %}
{# End generated Service code #}

{% endif %}
{# END REBOOT SPECIFIC CODE #}

export function importPys() {
    {% if import_ids|length > 0 %}
    {% for unique_import_id, _ in import_ids.items() %}
    {{ unique_import_id }}importPys()
    {% endfor %}
    {% endif %}

    reboot_native.importPy("{{ pb2_name }}", "{{ base64_gzip_pb2_py }}");
    reboot_native.importPy("{{ pb2_grpc_name }}", "{{ base64_gzip_pb2_grpc_py }}");
    {% if clients | length > 0 %}
    reboot_native.importPy("{{ rbt_name }}", "{{ base64_gzip_rbt_py }}");
    {% endif %}
}

importPys()
