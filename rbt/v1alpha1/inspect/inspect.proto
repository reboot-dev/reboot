syntax = "proto3";

package rbt.v1alpha1.inspect;

import "google/api/annotations.proto";
import "google/api/httpbody.proto";

////////////////////////////////////////////////////////////////////////

message GetStateTypesRequest {}

message GetStateTypesResponse {
  // The state types that are currently registered.
  repeated string state_types = 1;
}

////////////////////////////////////////////////////////////////////////

// Information about a single state.
message StateInfo {
  // The state ID.
  string state_id = 1;

  // The ID of the server that hosts this state.
  string server_id = 2;

  // The index of the replica that hosts this state.
  uint32 replica_index = 3;
}

message ListStatesRequest {
  // If set, only return states served by the given server ID. If not
  // set (or left at default), return all states held by all servers.
  string only_server_id = 1;

  // The state type to list states for.
  string state_type = 2;
}

message ListStatesResponse {
  repeated StateInfo state_infos = 1;
}

////////////////////////////////////////////////////////////////////////

message GetStateRequest {
  // This request is expected to have the `x-reboot-state-ref` header
  // set, which identifies the state that should be fetched (as well as
  // ensuring the request is routed correctly). No further parameters
  // are needed.
}

message GetStateResponse {
  // Data is returned as a `chunk`, e.g, 3 (zero based), of some
  // `total`, e.g., 4, so as to account for max message size which is
  // 4MB by default for gRPC (and actually 1MB by default for Envoy's
  // gRPC-JSON transcoder which we set to also be 4MB to match gRPC).
  uint32 chunk = 1;
  uint32 total = 2;

  // Serialized bytes of a `google.protobuf.Struct` representing the
  // single state requested. If the state doesn't exist, this will be
  // an empty Struct.
  bytes data = 3;
}

////////////////////////////////////////////////////////////////////////

service Inspect {
  // The list of state types in an application is static, however, we
  // make this a streaming RPC so that the client can hear when it
  // disconnects from the server and retry its call. Disconnects can
  // mean that a new version of the app may have been deployed, and the
  // state types may have changed, and the retry will ensure that the
  // client gets the latest list.
  rpc GetStateTypes(GetStateTypesRequest)
      returns (stream GetStateTypesResponse) {}

  // List states for a given state type.
  rpc ListStates(ListStatesRequest) returns (stream ListStatesResponse) {}

  // Get the data for a single state.
  rpc GetState(GetStateRequest) returns (stream GetStateResponse) {}

  // Serve a web dashboard. Uses `HttpBody` to return arbitrary content (HTML,
  // JS) to callers; see `httpbody.proto` for more details.
  rpc WebDashboard(WebDashboardRequest) returns (google.api.HttpBody) {
    option (google.api.http) = {
      get: "/__/inspect"
      additional_bindings {
        // The 'index.html' will want to load a few further files,
        // most notably 'bundle.js'. Furthermore, the inspect page might
        // use some "slash/delimited" paths to load specific resources
        // in its single-page app.
        get: "/__/inspect/{file=**}"
      }
    };
  }
}

////////////////////////////////////////////////////////////////////////

message WebDashboardRequest {
  string file = 1;
}
